//3D Printer and Application Interface (Team 21)
//Microcontroller Subsystem
//ESP32S3 MCU Program for controlling all aspects of the 3D Printer
//Programmed by: Abigail Morar

//Header files
#include <FirebaseESP32.h>
#include <WiFi.h>
#include <Stepper.h>

//Firebase & WiFi credentials
#define FIREBASE_HOST "https://d-printer-b61f0-default-rtdb.firebaseio.com/"
#define FIREBASE_AUTH "N9Sx45ahrrGiOtH4DnJRjGf6wurleIxwdpEJJRRT"
#define WIFI_SSID "Moto Z"
#define WIFI_PASSWORD "jeepjeep"

//Firebase object initialization
FirebaseData firebaseData;
FirebaseJson jsonReport, jsonStatus, jsonLast;

// Firebase paths to/from app data
#define PRINT "/Start Print/Command Print/beginPrint"  //reading from
#define NUMBER "/Start Print/Command Print/fileNumLines"  //reading from
#define NAME "/Start Print/Command Print/fileName"  //reading from
#define GCODE "/Print Files Readable/"  //reading from
#define CHECK "/Printer Formatting/Format"  //reading from
#define REPORT "/Printer Formatting Test/Format" //writing to
#define STATUS "/Start Print/Command Print" //writing to

//Stepper motor pins
#define MOTOR_X_VCC 4
#define MOTOR_X_DIR 5
#define MOTOR_X_STEP 6
#define MOTOR_Y_VCC 7
#define MOTOR_Y_DIR 15
#define MOTOR_Y_STEP 16
#define MOTOR_Z_VCC 17
#define MOTOR_Z_DIR 18
#define MOTOR_Z_STEP 8
#define MOTOR_E_VCC 3
#define MOTOR_E_DIR 46
#define MOTOR_E_STEP 9
#define MOTOR_ENABLE 10

//Axis switch limiters
#define X_SWITCH_LIM 12
#define X_SWITCH_LIM_OUTPUT 38
#define Y_SWITCH_LIM 13
#define Y_SWITCH_LIM_OUTPUT 37
#define Z_SWITCH_LIM 14
#define Z_SWITCH_LIM_OUTPUT 36

//Heated bed pins
#define HEATED_BED_CTRL 43
#define HEATED_BED_THERM_OUT 44
#define HEATED_BED_THERM_IN 1

//Hotend pins
#define HOTEND_CTRL 2
#define HOTEND_THERM_OUT 42
#define HOTEND_THERM_IN 19

//Fan control pins
#define FAN_CTRL_1 40
#define FAN_CTRL_2 39

//Firebase and parsing global variables
String printing;
String prevFanSpeed;
String updateXpos, updateYpos, updateZpos;
float oldXpos, moveXpos, prevXpos = 0.000;
float oldYpos, moveYpos, prevYpos = 0.000;
float oldZpos, moveZpos, prevZpos = 0.0;
float bed_resistance, Tbed, bed_temperature;
float head_resistance, Thead, head_temperature;
int prevBedTemp, getBedTemp;
int prevExtTemp, getExtTemp;
int commandNum;

//Stepper motor configurations
const int stepsPerRev = 12800;
const int stepsPermmXY = 320; //Y 40mm per full rev, so 320 steps/mm
const int stepsPermmZE = 1600;  //Z 8mm per full rev, so 1600 steps/mm

Stepper motorX(stepsPerRev, MOTOR_X_STEP, MOTOR_X_DIR);
Stepper motorY(stepsPerRev, MOTOR_Y_STEP, MOTOR_Y_DIR);
Stepper motorZ(stepsPerRev, MOTOR_Z_STEP, MOTOR_Z_DIR);
Stepper motorE(stepsPerRev, MOTOR_E_STEP, MOTOR_E_DIR);

//Heated component constants
const double A = -0.0543085096797757;
const double B = 0.0163042730921312;
const double C = -0.0015640625488228;
const double D = 0.0000506610073595609;

void setup() {
  Serial.begin(115200);

  //Firebase setup and connection
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
  }
  Firebase.begin(FIREBASE_HOST, FIREBASE_AUTH);
  Firebase.reconnectWiFi(true);
  //set database read timeout to 1 min (15 min max)
  Firebase.setReadTimeout(firebaseData, 1000 * 60);
  //size and write timeout (tiny=1s, small=10s, medium=30s, large=60s)
  Firebase.setwriteSizeLimit(firebaseData, "tiny");
  delay(500);

  //All pinMode setup
  pinMode(MOTOR_X_VCC, OUTPUT); //digitalWrite
  pinMode(MOTOR_Y_VCC, OUTPUT); //digitalWrite
  pinMode(MOTOR_Z_VCC, OUTPUT); //digitalWrite
  pinMode(MOTOR_E_VCC, OUTPUT); //digitalWrite
  pinMode(MOTOR_ENABLE, OUTPUT);  //digitalWrite
  pinMode(HEATED_BED_CTRL, OUTPUT); //digitalWrite
  pinMode(HEATED_BED_THERM_OUT, OUTPUT);  //digitalWrite, set high
  pinMode(HEATED_BED_THERM_IN, INPUT);  //analogRead
  pinMode(HOTEND_CTRL, OUTPUT); //digitalWrite
  pinMode(HOTEND_THERM_OUT, OUTPUT);  //digitalWrite, set high
  pinMode(HOTEND_THERM_IN, INPUT);  //analogRead
  pinMode(FAN_CTRL_1, OUTPUT);  //digitalWrite
  pinMode(FAN_CTRL_2, OUTPUT);  //digitalWrite
  pinMode(X_SWITCH_LIM, INPUT);  //analogRead, high untill pressed
  pinMode(X_SWITCH_LIM_OUTPUT, OUTPUT);
  pinMode(Y_SWITCH_LIM, INPUT);  //analogRead, high untill pressed
  pinMode(Y_SWITCH_LIM_OUTPUT, OUTPUT);
  pinMode(Z_SWITCH_LIM, INPUT);  //analogRead, high untill pressed
  pinMode(Z_SWITCH_LIM_OUTPUT, OUTPUT);

  //Pin initial settings
  digitalWrite(MOTOR_X_VCC, HIGH);  //on
  digitalWrite(MOTOR_Y_VCC, HIGH);  //on
  digitalWrite(MOTOR_Z_VCC, HIGH);  //on
  digitalWrite(MOTOR_E_VCC, HIGH);  //on
  digitalWrite(MOTOR_ENABLE, HIGH);  //off
  digitalWrite(HEATED_BED_CTRL, LOW); //off
  digitalWrite(HEATED_BED_THERM_OUT, HIGH); //always on
  digitalWrite(HOTEND_CTRL, LOW); //off
  digitalWrite(HOTEND_THERM_OUT, HIGH); //always on
  digitalWrite(FAN_CTRL_1, LOW);  //off
  digitalWrite(FAN_CTRL_2, LOW);  //off
  digitalWrite(X_SWITCH_LIM_OUTPUT, HIGH);  //always on
  digitalWrite(Y_SWITCH_LIM_OUTPUT, HIGH);  //always on
  digitalWrite(Z_SWITCH_LIM_OUTPUT, HIGH);  //always on
//end of setup()
}

void gcode() {
  String reportStatus = "false";  //print started 
  jsonStatus.set("/print_complete", reportStatus);
  Firebase.updateNode(firebaseData, STATUS, jsonStatus);
  digitalWrite(MOTOR_X_VCC, HIGH);  //ensure motor on for print
  digitalWrite(MOTOR_Y_VCC, HIGH);
  digitalWrite(MOTOR_Z_VCC, HIGH);
  digitalWrite(MOTOR_E_VCC, HIGH);
  digitalWrite(MOTOR_ENABLE, LOW);  //enable motors for print
  Firebase.get(firebaseData, NUMBER); //get total number of nodes
  int nodeTotal = firebaseData.stringData().toInt();
  Firebase.get(firebaseData, NAME); //gets print job name
  String name = firebaseData.stringData();
  float X, Y, Z;
  for (int nodeNumber = 1; nodeNumber < (nodeTotal+1); nodeNumber++) {  //iterate every node till complete
    Firebase.get(firebaseData, GCODE + name + "/" + String(nodeNumber));  //get full node
    String node = firebaseData.stringData();
    int startIndex = 0, relative = 0, S = 0;
    while (startIndex < node.length()) {  //iterate each command till end of node
      int endIndex = node.indexOf('/', startIndex);
      if (endIndex == -1) {
        endIndex = node.length();
      }
      String gCode = node.substring(startIndex, endIndex);  //get individual command
      char *gCodeCopy;
      int lineLength = node.length();
      gCodeCopy = (char*) malloc((lineLength + 1) * sizeof(char));  //dynamically allocate enough memory on heap + null terminator
      gCode.toCharArray(gCodeCopy, lineLength + 1); //copy into a char to be parsed
      char command, argument, commandPos;
      char *token;
      float F, currentX, absoluteX, currentY, absoluteY, currentZ, absoluteZ, E, currentE, absoluteE, prevE, extrude, flowXY, flowZE;
      int limitx, limity, limitz;
      sscanf(gCodeCopy, "%c%i", &command, &commandNum); //get G or M command line
      if (command == 'G') { //parse G commands
        switch(commandNum) {
          case 0: //linear move of XYZ
            token = strtok(gCodeCopy, " "); //separate each token (FXYZ)
            if (token != NULL) {
              token = strtok(NULL, " ");
              while (token != NULL) { //categorize each token
                if (token[0] == 'X') {
                  X = atof(token+1);  //turn value after parameter into float
                }
                else if (token[0] == 'Y') {
                  Y = atof(token+1);
                }
                else if (token[0] == 'Z') {
                  Z = atof(token+1);
                }
                else if (token[0] == 'F') {
                  F = atof(token+1);
                }
                token = strtok(NULL, " ");
              }
            }
            if (relative = 1) { //execute when G91 is called
              absoluteX = absoluteX+X;  //maintain absolute location of extruder
              absoluteY = absoluteY+Y;
              absoluteZ = absoluteZ+Z;
              prevXpos = 0; //reset for relative moves
              prevYpos = 0;
              prevZpos = 0;
            }
            moveXpos = X-prevXpos;  //calculate extruder location value
            prevXpos = X; //remember previous location
            moveYpos = Y-prevYpos;
            prevYpos = Y;
            moveZpos = -1*(Z-prevZpos);
            prevZpos = Z;
            flowXY = F*stepsPermmXY/stepsPerRev;  //convert flow rate from mm/min to rpm
            flowZE = F*stepsPermmZE/stepsPerRev;
            motorX.setSpeed(flowXY); //set motor speed with flow value
            motorY.setSpeed(flowXY);
            motorZ.setSpeed(flowZE);
            motorX.step(moveXpos*stepsPermmXY); //execute extruder location value by steps per mm
            motorY.step(moveYpos*stepsPermmXY);
            motorZ.step(moveZpos*stepsPermmZE);
            updateXpos = String(prevXpos);  //set for firebase_report
            updateYpos = String(prevYpos);
            updateZpos = String(prevZpos);
            break;
          case 1: //linear move of XYZ and E
            token = strtok(gCodeCopy, " "); //separate each token (FXYZE)
            if (token != NULL) {
              token = strtok(NULL, " ");  //categorize each token
              while (token != NULL) {
                if (token[0] == 'X') {
                  X = atof(token+1);  //turn value after parameter into float
                }
                else if (token[0] == 'Y') {
                  Y = atof(token+1);
                }
                else if (token[0] == 'Z') {
                  Z = atof(token+1);
                }
                else if (token[0] == 'E') {
                  E = atof(token+1);
                }
                else if (token[0] == 'F') {
                  F = atof(token+1);
                }
                token = strtok(NULL, " ");
              }
            }
            if (relative = 1) { //execute when G91 is called
              absoluteX = absoluteX+X;  //maintain absolute location of extruder
              absoluteY = absoluteY+Y;
              absoluteZ = absoluteZ+Z;
              absoluteE = absoluteE+E;
              prevXpos = 0; //reset for relative moves
              prevYpos = 0;
              prevZpos = 0;
              prevE = 0;
            }
            moveXpos = X-prevXpos;  //calculate extruder location value
            prevXpos = X; //remember previous location
            moveYpos = Y-prevYpos;
            prevYpos = Y;
            moveZpos = -1*(Z-prevZpos);
            prevZpos = Z;
            extrude = E-prevE;
            prevE = E;
            flowXY = F*stepsPermmXY/stepsPerRev;  //convert flow rate from mm/min to rpm
            flowZE = F*stepsPermmZE/stepsPerRev;
            motorX.setSpeed(flowXY); //set motor speed with flow value
            motorY.setSpeed(flowXY);
            motorZ.setSpeed(flowZE);
            motorE.setSpeed(flowZE);
            motorE.step(extrude*stepsPermmZE);  //execute extruder location value by steps per mm
            motorX.step(moveXpos*stepsPermmXY);
            motorY.step(moveYpos*stepsPermmXY);
            motorZ.step(moveZpos*stepsPermmZE);
            updateXpos = String(prevXpos);  //set for firebase_report
            updateYpos = String(prevYpos);
            updateZpos = String(prevZpos);
            break;
          case 28:  //auto home XYZ
            limitx = analogRead(X_SWITCH_LIM);  //read limit switch adc value
            limity = analogRead(Y_SWITCH_LIM);
            limitz = analogRead(Z_SWITCH_LIM);
            motorX.setSpeed(90);  //set default motor speed
            motorY.setSpeed(90);
            motorZ.setSpeed(90);  //225?
            while (limitx > 100) {  //if high (on)
              motorX.step(-stepsPermmXY); //move home
              limitx = analogRead(X_SWITCH_LIM);
            }
            while (limitx < 100) {  //if low (off) [@ home]
              motorX.step(stepsPermmXY);  //move away from switch till high
              limitx = analogRead(X_SWITCH_LIM);
            }
            motorX.step(0); //stop moving

            while (limity > 100) {
              motorY.step(-stepsPermmXY);
              limity = analogRead(Y_SWITCH_LIM);
            }
            while (limity < 100) {
              motorY.step(stepsPermmXY);
              limity = analogRead(Y_SWITCH_LIM);
            }
            motorY.step(0);

            while (limitz > 100) {
              motorZ.step(stepsPermmZE);
              limitz = analogRead(Z_SWITCH_LIM);
            }
            while (limitz < 100) {
              motorZ.step(-stepsPermmZE);
              limitz = analogRead(Z_SWITCH_LIM);
            }
            motorZ.step(0);

            X = 0.0, Y = 0.0, Z = 0.0;
            prevXpos = X, prevYpos = Y, prevZpos = Z;
            updateXpos = String(prevXpos);  //set for firebase_report
            updateYpos = String(prevYpos);
            updateZpos = String(prevZpos);
            break;
          case 90:  //absolute positioning (default) (move extruder to #mm position)
            relative = 0; //off
            prevXpos = absoluteX; //continue absolute location
            prevYpos = absoluteY;
            prevZpos = absoluteZ;
            prevE = absoluteE;
            break;
          case 91:  //relative positioning (move extruder +/- #mm)
            relative = 1; //on
            absoluteX = prevXpos; //maintain absolute location
            absoluteY = prevYpos;
            absoluteZ = prevZpos;
            absoluteE = prevE;
            break;
          case 92:  //set position
            E = 0;  //reset extruder
            prevE = E;
            break;
          default:
            break;
        }
      }
      else if (command == 'M') {  //parse M commands
        switch(commandNum) {
          case 82:  //absolute extrusion mode
            E = 0;  //reset extruder
            prevE = E;
            break;
          case 84:  //disable specified steppers
            token = strtok(gCodeCopy, " "); //separate each token (XYZE)
            if (token != NULL) {
              token = strtok(NULL, " ");  //categorize each token
              while (token != NULL) {
                if (token[0] == 'X') {
                  digitalWrite(MOTOR_X_VCC, LOW); //disable existing parameter
                }
                else if (token[0] == 'Y') {
                  digitalWrite(MOTOR_Y_VCC, LOW);
                }
                else if (token[0] == 'Z') {
                  digitalWrite(MOTOR_Z_VCC, LOW);
                }
                else if (token[0] == 'E') {
                  digitalWrite(MOTOR_E_VCC, LOW);
                }
                else {  //if parameter empty, disable all steppers
                  digitalWrite(MOTOR_X_VCC, LOW);
                  digitalWrite(MOTOR_Y_VCC, LOW);
                  digitalWrite(MOTOR_Z_VCC, LOW);
                  digitalWrite(MOTOR_E_VCC, LOW);
                }
                token = strtok(NULL, " ");
              }
            }
            break;
          case 104: //set hotend temperature  //REVISIT CASE IN LOOP
            sscanf(gCodeCopy, "%*4c S%d", &S);  //get desired temperature value
            if (S == 0) { //turn off 
              digitalWrite(HOTEND_CTRL, LOW);              
            }
            else {
              getExtTemp = analogRead(HOTEND_THERM_IN); //read temperature adc value
              head_resistance = ((4095*10000)/getExtTemp)-10000;  //calculate thermistor resistance
              Thead = 1/(A+(B*log(head_resistance))+(C*(pow(log(head_resistance),2.0)))+(D*(pow(log(head_resistance),3.0)))); //calculate Steinhart-Hart equation
              head_temperature = Thead - 273.15;  //convert temperature K to degC
              if (head_temperature < S) { //heat up
                digitalWrite(HOTEND_CTRL, HIGH);
              }
              else {  //cool down
                digitalWrite(HOTEND_CTRL, LOW);
              }
            }
            break;
          case 105: //report temperatures
            //M104 hotend temp report
            getExtTemp = analogRead(HOTEND_THERM_IN); //read temperature adc value
            head_resistance = ((4095*10000)/getExtTemp)-10000;  //calculate thermistor resistance
            Thead = 1/(A+(B*log(head_resistance))+(C*(pow(log(head_resistance),2.0)))+(D*(pow(log(head_resistance),3.0)))); //calculate Steinhart-Hart equation
            head_temperature = Thead - 273.15;  //convert temperature K to degC
            //M140 heated bed temp report
            getBedTemp = analogRead(HEATED_BED_THERM_IN); //read temperature adc value
            bed_resistance = ((4095*10000)/getBedTemp)-10000; //calculate thermistor resistance
            Tbed = 1/(A+(B*log(bed_resistance))+(C*(pow(log(bed_resistance),2.0)))+(D*(pow(log(bed_resistance),3.0)))); //calculate Steinhart-Hart equation
            bed_temperature = Tbed - 273.15;  //convert temperature K to degC
            break;
          case 106: //set fan speed
            sscanf(gCodeCopy, "%*4c S%d", &S);  //get desired fan power
            if (S == 0) { //turn off
              digitalWrite(FAN_CTRL_1, LOW);
              digitalWrite(FAN_CTRL_2, LOW);
              prevFanSpeed = "OFF"; //set for firebase_report
            }
            else if (S < 128) { //halfway
              digitalWrite(FAN_CTRL_1, HIGH);
              digitalWrite(FAN_CTRL_2, LOW);
              prevFanSpeed = "LOW";
            }
            else {  //full on
              digitalWrite(FAN_CTRL_1, HIGH);
              digitalWrite(FAN_CTRL_2, HIGH);
              prevFanSpeed = "HIGH";
            }
            break;
          case 107: //fan off
            digitalWrite(FAN_CTRL_1, LOW);
            digitalWrite(FAN_CTRL_2, LOW);
            prevFanSpeed = "OFF"; //set for firebase_report
            break;
          case 109: //wait for hotend temperature
            sscanf(gCodeCopy, "%*4c S%d", &S);  //get desired temperature value
            getExtTemp = analogRead(HOTEND_THERM_IN); //read temperature adc value
            head_resistance = ((4095*10000)/getExtTemp)-10000;  //calculate thermistor resistance
            Thead = 1/(A+(B*log(head_resistance))+(C*(pow(log(head_resistance),2.0)))+(D*(pow(log(head_resistance),3.0)))); //calculate Steinhart-Hart equation
            head_temperature = Thead - 273.15;  //convert temperature K to degC
            while (head_temperature < S) {  //heat up till desired temperature reached
              digitalWrite(HOTEND_CTRL, HIGH);
              getExtTemp = analogRead(HOTEND_THERM_IN); //read temperature adc value
              head_resistance = ((4095*10000)/getExtTemp)-10000;  //calculate thermistor resistance
              Thead = 1/(A+(B*log(head_resistance))+(C*(pow(log(head_resistance),2.0)))+(D*(pow(log(head_resistance),3.0)))); //calculate Steinhart-Hart equation
              head_temperature = Thead - 273.15;  //convert temperature K to degC
              firebase_report();  //report temperature increasing
            }
            break;
          case 140: //set bed temperature //REVISIT CASE IN LOOP
            sscanf(gCodeCopy, "%*4c S%d", &S);  //get desired temperature value
            if (S == 0) { //turn off 
              digitalWrite(HEATED_BED_CTRL, LOW);             
            }
            else {
              getBedTemp = analogRead(HEATED_BED_THERM_IN); //read temperature adc value
              bed_resistance = ((4095*10000)/getBedTemp)-10000; //calculate thermistor resistance
              Tbed = 1/(A+(B*log(bed_resistance))+(C*(pow(log(bed_resistance),2.0)))+(D*(pow(log(bed_resistance),3.0)))); //calculate Steinhart-Hart equation
              bed_temperature = Tbed - 273.15;  //convert temperature K to degC
              if (bed_temperature < S) {  //heat up
                digitalWrite(HEATED_BED_CTRL, HIGH);
              }
              else {  //cool down
                digitalWrite(HEATED_BED_CTRL, LOW);
              }
            }
            break;
          case 190: //wait for bed temperature
            sscanf(gCodeCopy, "%*4c S%d", &S);  //get desired temperature value
            getBedTemp = analogRead(HEATED_BED_THERM_IN); //read temperature adc value
            bed_resistance = ((4095*10000)/getBedTemp)-10000; //calculate thermistor resistance
            Tbed = 1/(A+(B*log(bed_resistance))+(C*(pow(log(bed_resistance),2.0)))+(D*(pow(log(bed_resistance),3.0)))); //calculate Steinhart-Hart equation
            bed_temperature = Tbed - 273.15;  //convert temperature K to degC
            while (bed_temperature < S) { //heat up till desired temperature reached
              digitalWrite(HEATED_BED_CTRL, HIGH);
              getBedTemp = analogRead(HEATED_BED_THERM_IN); //read temperature adc value
              bed_resistance = ((4095*10000)/getBedTemp)-10000; //calculate thermistor resistance
              Tbed = 1/(A+(B*log(bed_resistance))+(C*(pow(log(bed_resistance),2.0)))+(D*(pow(log(bed_resistance),3.0)))); //calculate Steinhart-Hart equation
              bed_temperature = Tbed - 273.15;  //convert temperature K to degC
              firebase_report();  //report temperature increasing
            }
            break;
          default:
            break;
        }
      }
      firebase_report();  //report information
      firebase_check(); //check for user input changes
      free(gCodeCopy);  //empty string
      Firebase.get(firebaseData, PRINT);  //check if print is cancelled by user
      printing = firebaseData.stringData();
      if (printing == "false") {  //if print cancelled early
        startIndex = node.length(); //end while loop
        nodeNumber = nodeTotal; //end for loop
        digitalWrite(HEATED_BED_CTRL, LOW); //turn off heating
        digitalWrite(HOTEND_CTRL, LOW); //turn off heating
        digitalWrite(FAN_CTRL_1, LOW);  //turn off fans
        digitalWrite(FAN_CTRL_2, LOW);  //turn off fans
      }
      else {
        startIndex = endIndex + 1;  //go to next command line
      }
    }
    if (printing != "false") {  //if print still in progress, execute after every node (~100 lines)
      getBedTemp = analogRead(HEATED_BED_THERM_IN); //maintain temp
      bed_resistance = ((4095*10000)/getBedTemp)-10000; //calculate thermistor resistance
      Tbed = 1/(A+(B*log(bed_resistance))+(C*(pow(log(bed_resistance),2.0)))+(D*(pow(log(bed_resistance),3.0)))); //calculate Steinhart-Hart equation
      bed_temperature = Tbed - 273.15;  //convert temperature K to degC
      if (bed_temperature < S) {  //heat up
        digitalWrite(HEATED_BED_CTRL, HIGH);
      }
      else {  //cool down
        digitalWrite(HEATED_BED_CTRL, LOW);
      }
      getExtTemp = analogRead(HOTEND_THERM_IN); //maintain temp
      head_resistance = ((4095*10000)/getExtTemp)-10000;  //calculate thermistor resistance
      Thead = 1/(A+(B*log(head_resistance))+(C*(pow(log(head_resistance),2.0)))+(D*(pow(log(head_resistance),3.0)))); //calculate Steinhart-Hart equation
      head_temperature = Thead - 273.15;  //convert temperature K to degC
      if (head_temperature < S) { //heat up
        digitalWrite(HOTEND_CTRL, HIGH);
      }
      else {  //cool down
        digitalWrite(HOTEND_CTRL, LOW);
      }
    }
  }
  digitalWrite(MOTOR_X_VCC, HIGH);  //turn motor back on
  digitalWrite(MOTOR_Y_VCC, HIGH);
  digitalWrite(MOTOR_Z_VCC, HIGH);
  digitalWrite(MOTOR_E_VCC, HIGH);
  digitalWrite(MOTOR_ENABLE, HIGH); //disable motors
  reportStatus = "true";  //print complete  
  jsonStatus.set("/print_complete", reportStatus);
  Firebase.updateNode(firebaseData, STATUS, jsonStatus);
  //user changes picks up where G-code last left off
  String lastBedTemp = "0", lastExtTemp = "0", lastFanSpeed = "OFF", lastXpos = String(X), lastYpos = String(Y), lastZpos = String(Z);
  jsonLast.set("/bed_temp", lastBedTemp);
  jsonLast.set("/ext_temp", lastExtTemp);
  jsonLast.set("/fan_speed", lastFanSpeed);
  jsonLast.set("/x_pos", lastXpos);
  jsonLast.set("/y_pos", lastYpos);
  jsonLast.set("/z_pos", lastZpos);
  Firebase.updateNode(firebaseData, CHECK, jsonLast);
//end of gcode()  
}

void parse() {
  switch(commandNum) {
    case 0:   //linear move of XYZ (absolute positioning from firebase_check)
      digitalWrite(MOTOR_ENABLE, LOW);  //enable motors
      motorX.setSpeed(90);  //set default motor speed
      motorY.setSpeed(90);
      motorZ.setSpeed(90);
      motorX.step(moveXpos*stepsPermmXY); //execute extruder location value by steps per mm
      motorY.step(moveYpos*stepsPermmXY);
      motorZ.step(moveZpos*stepsPermmZE);
      digitalWrite(MOTOR_ENABLE, HIGH); //disable motors
      break;
    case 104: //set hotend temperature  //REVISIT CASE IN LOOP
      if (prevExtTemp == 0) { //turn off
        digitalWrite(HOTEND_CTRL, LOW);
      }
      else {
        getExtTemp = analogRead(HOTEND_THERM_IN); //read temperature adc value
        head_resistance = ((4095*10000)/getExtTemp)-10000;  //calculate thermistor resistance
        Thead = 1/(A+(B*log(head_resistance))+(C*(pow(log(head_resistance),2.0)))+(D*(pow(log(head_resistance),3.0)))); //calculate Steinhart-Hart equation
        head_temperature = Thead - 273.15;  //convert temperature K to degC
        if (head_temperature < prevExtTemp) { //heat up
          digitalWrite(HOTEND_CTRL, HIGH);
        }
        else {  //cool down
          digitalWrite(HOTEND_CTRL, LOW);
        }
      }
      break;
    case 106: //set fan speed
      if (prevFanSpeed == "HIGH") {
        digitalWrite(FAN_CTRL_1, HIGH);
        digitalWrite(FAN_CTRL_2, HIGH);
      }
      else if (prevFanSpeed == "LOW") {
        digitalWrite(FAN_CTRL_1, HIGH);
        digitalWrite(FAN_CTRL_2, LOW);
      }
      //0=0%, 128=50%, 255=100%
      break;
    case 107: //fan off
      digitalWrite(FAN_CTRL_1, LOW);
      digitalWrite(FAN_CTRL_2, LOW);
      break;
    case 140: //set bed temperature //REVISIT CASE IN LOOP
      if (prevBedTemp == 0) { //turn off
        digitalWrite(HEATED_BED_CTRL, LOW);
      }
      else {
        getBedTemp = analogRead(HEATED_BED_THERM_IN); //read temperature adc value
        bed_resistance = ((4095*10000)/getBedTemp)-10000; //calculate thermistor resistance
        Tbed = 1/(A+(B*log(bed_resistance))+(C*(pow(log(bed_resistance),2.0)))+(D*(pow(log(bed_resistance),3.0)))); //calculate Steinhart-Hart equation
        bed_temperature = Tbed - 273.15;  //convert temperature K to degC
        if (bed_temperature < prevBedTemp) {  //heat up
          digitalWrite(HEATED_BED_CTRL, HIGH);
        }
        else {  //cool down
          digitalWrite(HEATED_BED_CTRL, LOW);
        }
      }
      break;
    default:
      break;
  }
  firebase_report();  //report information
//end of parse()
}

void firebase_report() {
  String reportBedTemp = String(bed_temperature);
  String reportExtTemp = String(head_temperature);
  String reportFanSpeed = prevFanSpeed;
  String reportXpos = updateXpos;
  String reportYpos = updateYpos;
  String reportZpos = updateZpos;

  jsonReport.set("/bed_temp", reportBedTemp);
  jsonReport.set("/ext_temp", reportExtTemp);
  jsonReport.set("/fan_speed", reportFanSpeed);
  jsonReport.set("/x_pos", reportXpos);
  jsonReport.set("/y_pos", reportYpos);
  jsonReport.set("/z_pos", reportZpos);
  Firebase.updateNode(firebaseData, REPORT, jsonReport);
//end of firebase_report()
}

void firebase_check() {
  Firebase.get(firebaseData, PRINT);  //check if print in progress
  printing = firebaseData.stringData();
  Firebase.get(firebaseData, CHECK"/bed_temp"); //get new values from user
  String newBedTemp = firebaseData.stringData();
  int newBedTempint = newBedTemp.toInt();
  Firebase.get(firebaseData, CHECK"/ext_temp");
  String newExtTemp = firebaseData.stringData();
  int newExtTempint = newExtTemp.toInt();
  Firebase.get(firebaseData, CHECK"/fan_speed");
  String newFanSpeed = firebaseData.stringData();

  if (newBedTemp != NULL) {
    prevBedTemp = newBedTempint;
  } //maintain previous value if unchanged
  commandNum = 140;
  parse();  //execute command

  if (newExtTemp != NULL) {
    prevExtTemp = newExtTempint;
  } //maintain previous value if unchanged
  commandNum = 104;
  parse();  //execute command

  if (newFanSpeed != NULL) {
    prevFanSpeed = newFanSpeed;
  } //maintain previous value if unchanged
    if (prevFanSpeed != "OFF") {
      commandNum = 106;
    }
    else {
      commandNum = 107;
    }
  parse();  //execute command

  if (printing == "false") {  //absolute positioning (G90) in manual movement
    Firebase.get(firebaseData, CHECK"/x_pos");  //get new location from user if print not in progress
    String newXpos = firebaseData.stringData();
    Firebase.get(firebaseData, CHECK"/y_pos");
    String newYpos = firebaseData.stringData();
    Firebase.get(firebaseData, CHECK"/z_pos");
    String newZpos = firebaseData.stringData();
      if (newXpos != NULL) {
        updateXpos = newXpos;
        oldXpos = prevXpos; //remember previous location
        prevXpos = newXpos.toFloat(); //store new location
        moveXpos = prevXpos-oldXpos;  //calculate extruder location value
      }
      else {  //maintain previous coordinates if unchanged
        oldXpos = prevXpos;
        moveXpos = prevXpos-oldXpos;  //0 mm change
      }
      if (newYpos != NULL) {
        updateYpos = newYpos;
        oldYpos = prevYpos;
        prevYpos = newYpos.toFloat();
        moveYpos = prevYpos-oldYpos;
      }
      else {
        oldYpos = prevYpos;
        moveYpos = prevYpos-oldYpos;
      }
      if (newZpos != NULL) {
        updateZpos = newZpos;
        oldZpos = prevZpos;
        prevZpos = newZpos.toFloat();
        moveZpos = -1*(prevZpos-oldZpos);
      }
      else {
        oldZpos = prevZpos;
        moveZpos = -1*(prevZpos-oldZpos);
      }
    commandNum = 0;
    parse();  //execute command
  }
//end of firebase_check()
}

void loop() {
  delay(100); //delay to not overwhelm MCU
  Firebase.get(firebaseData, PRINT);  //check if print in progress
  printing = firebaseData.stringData();
  if (printing == "false") {  //user controls all aspects of printer
    firebase_check(); //check for user input changes
    commandNum = 104;
    parse();  //execute command
    commandNum = 140;
    parse();  //execute command
  }
  else {  //execute G-code file, user may not change extruder location
    gcode();
    delay(3000);  //delay for a break after print job is complete
  }
//end of loop()
}
